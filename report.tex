\documentclass[12pt]{article}
\usepackage{fullpage}
\usepackage{color}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{comment}
\usepackage{verbatim}

\title{XINU Independent Study Report}
\author{David Larsen}
\date{\today}

\newcommand{\TODO}[1]{{\huge\color{red}TODO \Large #1}}
\newcommand{\code}[1]{{\tt #1}}

\begin{document}

\maketitle

\tableofcontents

\section{XINU Is Not U{\small NIX} (overview)}

\subsection{Motivation}

XINU is a very simple operating system that originally ran on the PDP-11. It's
maintained its simple design by choice: it's primary purpose is to provide a
platform for teaching operating systems courses. The latest platform XINU has
been ported to is the MIPS-based Linksys routers, with the idea that the
Linksys routers are a cheap platform (about \$60 each) with a simple
architecture.

In that spirit, we decided that we'd like to try to port XINU to the ARM
platform because of the recent release of the even cheaper (\$35) Raspberry-PI
and the opportunity to do a cool project.

\subsection{ARM ISA}

\TODO{}

\subsection{ARM Versatile Baseboard}

\TODO{}

\subsection{Raspberry-PI}

\TODO{}

\section{Handling interrupts and context switches}

\TODO{Intro to section}

\subsection{Exception states in the ARM core}

The ARM processor supports several operating states, depending on what
exception mode it's in. While there are several modes not listed here, we
decided to only use the user, system and interrupt modes.

When an exception happens in ARM (timer advances, user presses a key or a
software interrupt is generated), the ARM core saves the user's stack pointer
and link register\footnote{The link register contains the return address for
the current function. ARM has a register for this, rather than always pushing
the return address on the stack, so that leaf-function calls have fewer
load-store operations to do.} and swaps in a separate stack pointer and link
register used for exception modes\footnote{Every mode, except for system mode,
has its own stack pointer and link register.}. Having a separate stack for
exception handling is pretty cool, but operating on a separate stack can
quickly become annoying if the active process's time quantum has expired (via
the timer interrupt) and the scheduler needs to be called.

To switch the active process context, the interrupt handler needs to have
access to the user-mode stack pointer and link register so that the new process
will be running when the system returns from the interrupt.  Privileged
operating modes have the ability to manually change the operating mode that the
ARM core is in. The processor must be in IRQ mode to successfully properly
return from the interrupt, so we need to be able to switch to a mode that has
access to the user stack, change the active process, return to IRQ mode and
return. Since there's no going back once you switch to user mode, the ARM
architects added the system mode, which has access to all of the user mode
registers.

\begin{table}[h]
\caption{Traits of different ARM operating modes}
\label{arm-modes}
\center
\begin{tabular}{| r || c | c | c |}
\hline
mode & stack & link register & privileged \\\hline\hline
user & user & user & no \\\hline
system & user & user & yes \\\hline
interrupt & interrupt & interrupt & yes \\\hline
\end{tabular}
\end{table}

\subsection{Context switching in XINU's scheduler}
In most operating systems, all of the context switching is done at the entry
and exit of the top-level ISR. When the scheduler changes the active process,
the pointer to the active process' context is changed and all of the heavy
lifting for context switching is differed to the top-level ISR.

XINU has two ways that context switching can be done: via servicing an
interrupt (as above) or in the middle of a syscall, without changing processor
modes. XINU does context switching so deep into the call stack because they
want every function to return in a predictable way. \TODO{reword}

As designed, the context switcher in the schedule needs to accommodate new
processes, as well as existing ones. New processes in XINU have their stack and
context set up by the \code{create()} function so that their arguments are
passed properly and the scheduler will have them ``return'' to their main
function when they begin. As you look at Figure \ref{ctxsw}, notice that new
processes have a different value for their program counter and return address.
The return address for new programs is a special accounting function in the
kernel, so that the kernel can free up resources after a process terminates by
returning from its \code{main()} function.

\begin{figure}
\caption{Context save/restore in the scheduler}
\label{ctxsw}
\small
\begin{verbatim}
ctxsw:
	/* Store all registers. */
	/* We save lr twice because new processes can branch two ways:
	 * - proceed to their first instruction, via pc.
	 * - return via lr, which points to INTIRET. This puts kill() at the
	 *   bottom of the call stack, so that we can reap a process when it's
	 *   terminated.
	 * All of this is set-up for us in create(), which builds the context
	 * for new processes.
	 *
	 * Existing processes don't get a choice, they have to return to where
	 * lr tells them to. We push lr twice for existing process so that it's
	 * balanced with the pops, lower down in this function.
	 */
	push	{lr}
	push	{lr}
	push	{r0-ip}
	/* Notice, we don't push sp, that's handled by resched(). */

	/* Save sp to location given in argument 1, but only if the address is
	 * non-null. */
	cmp	r0, #0			@ Null address?
	strne	sp, [r0, #0]		@ Nope, store it!

	/* Restore all of the registers, for the new thread. */
	cmp	r1, #0
	ldrne	sp, [r1, #0]

	/* Restore all of the registers. */
	pop	{r0-ip}
	pop	{lr}
	pop	{pc}
	.end ctxsw
\end{verbatim}
\end{figure}

\subsection{Context switching in the ARM ISR}

\begin{figure}
\caption{Context save in the top-level ISR}
\small
\begin{verbatim}
     1	IRQ_Routine:
     2		/*
     3		 * With pipelining on ARM, the PC is 2 instructions (8 bytes) ahead of
     4		 * where we're currently executing. Usually the 'bl' instruction will
     5		 * subtract 4 from the PC before storing it in LR, but since we came in
     6		 * here via an exception we must do it ourselves.
     7		 */
     8		sub	lr, lr, #4
     9	
    10		/* Store lr_irq and the SPSR on the user stack */
    11		push	{r0}
    12		sub	sp, sp, #4
    13		stmia	sp, {sp}^		@ Grab sp_usr
    14		ldmfd	sp, {r0}		@ And load it into r0
    15		add	sp, sp, #4
    16	
    17		sub	r0, r0, #4
    18		stmia	r0, {lr}		@ Store lr_irq
    19		mrs	lr, spsr
    20		sub	r0, r0, #4
    21		stmia	r0, {lr}		@ Store the spsr
    22		pop	{r0}
    23	
    24		msr	cpsr, #MODE_SYS|I_BIT	@ Switch to sysmode, keep irq disabled
    25	
    26		/*
    27		 * When we saved the lr_irq and the SPSR earlier, we weren't able to
    28		 * modify the user mode stack pointer. Now we can adjust sp_usr to
    29		 * account for what is effectively a 'push {spsr,lr_irq}'.
    30		 */
    31		sub	sp, sp, #8		@ Make room for lr_irq and SPSR
    32		push	{r0-r3,r12,r14}		@ Push APCS registers
    33	
    34	       /* Call the ISR */
    35	       LDR    r0, =VIC_BASE_ADDRESS
    36	       LDR    r1, [r0, #VIC_VEC_ADDR] /* Discover source of interrupt */
    37	       cmp    r1, #0
    38	       beq    panic_no_isr
    39	       blx    r1
\end{verbatim}
\end{figure}

\begin{figure}
\caption{Context restore in the top-level ISR}
\small
\begin{verbatim}
    40	# Return from C ISR handler.
    41		pop	{r0-r3,r12,r14}		@ Pop APCS registers
    42	
    43		/*
    44		 * Prematurely 'pop' here, since we can't modify sp_usr in IRQ mode when we
    45		 * really do restore lr_irq and SPSR.
    46		 */
    47		add	sp, sp, #8
    48	
    49		/* Enable interrupts and switch back to IRQ mode to use sp_irq again. */
    50		msr	cpsr, #MODE_IRQ|I_BIT
    51	
    52		/* Load lr_irq from the user stack */
    53		push	{r0}
    54		sub	sp, sp, #4
    55		stmia	sp, {sp}^		@ Grab sp_usr
    56		ldmfd	sp, {r0}		@ And load it into r0
    57		add	sp, sp, #4
    58	
    59		sub	r0, r0, #8		@ Undo the premature add from earlier
    60		ldmfd	r0, {lr}
    61		msr	spsr_cxsf, lr		@ Restore spsr
    62		add	r0, r0, #4
    63		ldmfd	r0, {lr}		@ Restore lr_isr
    64		add	r0, r0, #4		@ nop
    65		pop	{r0}
    66	
    67		/* Restore cpsr and return. */
    68		subs	pc, lr, #0		@ Special ISR return instruction
    69	
    70	.endfunc
    71	.end
\end{verbatim}
\end{figure}

\section{XINU's platform configuration compiler}

\subsection{Adding devices to a XINU platform}

Marquette University's version of XINU includes a small compiler for
transforming a description of the hardware for a specific plaform into header
files and a routine that populates the device table at startup.

So, the description:

\begin{verbatim}
uart:
        on HARDWARE -i uartInit     -o ionull        -c ionull
                    -r uartRead    -g uartGetc       -w uartWrite 
                    -n ionull      -p uartPutc       -intr uartInterrupt

SERIAL0   is uart     on HARDWARE csr 0x101F1000 irq 12
\end{verbatim}

will generate a device entry like this:

\begin{verbatim}
typedef struct dentry
{
        int     num;
        int     minor;
        char    *name;
        devcall (*init)(struct dentry *);
        devcall (*open)(struct dentry *, ...);
        devcall (*close)(struct dentry *);
        devcall (*read)(struct dentry *, void *, uint);
        devcall (*write)(struct dentry *, void *, uint);
        devcall (*seek)(struct dentry *, long);
        devcall (*getc)(struct dentry *);
        devcall (*putc)(struct dentry *, char);
        devcall (*control)(struct dentry *, int, long, long);
        void    *csr;
        void    (*intr)(void);
        uchar   irq;
} device;

[...]

	{ 0, 0, "SERIAL0",
	  (void *)uartInit, (void *)ionull, (void *)ionull,
	  (void *)uartRead, (void *)uartWrite, (void *)ioerr,
	  (void *)uartGetc, (void *)uartPutc, (void *)ionull,
	  (void *)0x101f1000, (void *)uartInterrupt, 12 },
\end{verbatim}

So, a routine like \code{puts()} only needs to call
\code{dentry[\$DEVICE].write()}, without caring what kind of device it is, or
how it's implemented.

\subsection{Fixing changes in Flex}

The compiler that generated these device entries depended on the values of some
components of Flex. In Flex 2.5.35, they changed the type of \code{yyleng} from
an \code{int} to a \code{size\_t}, since the length of a token could never be
negative. It was a reasonable change, but people using Flex historically don't
include a header file defining these types \---- everyone just re-defined them
and they matched up properly. This all broke with the type change for
\code{yyleng}.

Simply changing the defined type in the compiler to a \code{size\_t} wouldn't
work; then the project would only work for people who had really up to date
systems. The compiler had to be modified so that it started building header
files and using the declarations there.

\paragraph{The tightly coupled relationship between \code{lex} and \code{yacc}}
Lex and Yacc have an interesting relationship. Lex, on its own, can happily scan
through source files and emitting tokens that have been declared in its source
file. When we bring Yacc into the picture, it's not aware of the types of
tokens that it should be getting from Lex, and it has no desire to by told by
the lexer, what it should expect. Instead, Yacc must define the tokens and pass
them off to lex.

\begin{figure}
\caption{The dependency diagram for the lexer and parser.}
\label{lex-yacc-dependencies}
\includegraphics{graphs/lex_yacc_dependencies_dot.pdf}
\end{figure}

Our parser expects to be able to inspect a lot of things from the scanner, so
that it can manually copy over some parts of the source config file verbatim.
Because of this, we have an interweaving of mutually recursive dependencies
between the scanner and the parser. The original compiler coped with this by
including the entire scanner (after being generated by Flex) into the parser.

\paragraph{Using headers}
To cope with \code{yyleng} having different type on different platforms, we
needed to have the Flex implementation of each platform specify what the
correct type to use is. Neither Flex nor Bison have system-wide headers,
instead, they are generated at build time.

Since generating a header isn't a default thing to do in Flex, the generated
lexer defines a lot of it's own types. Some structures are defined differently
in the generated header and generated lexer (possibly to hide some information
from clients?).

\begin{figure}
\label{include-c-h}\caption{This generated type errors}
In the lex.yy.h:
\begin{verbatim}
#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
    /* stuff */
#endif
\end{verbatim}

In lex.yy.c:
\begin{verbatim}
#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
    /* stuff */
    /* Even more stuff, not defined before. */
#endif
\end{verbatim}

In the parser:
\begin{verbatim}
#include "lex.yy.h"
[... snip ...]
#include "lex.yy.c"
\end{verbatim}
\end{figure}

\paragraph{Separated, at last!}
Removing the generated scanner from the parser was easy enough, since they were
re-integrated at link-time. Removing the generated lexer revealed the 
parser depended on a static function in the lexer, which it no longer had
access to at link time. This function, \code{input()}, gave provided the raw
stream of characters that the lexer was looking at. The compiler was using that
function directly to support copying some parts of the configuration file over
into the destination config verbatim. This was fixed by moving the logic for
copying code over verbatim into the lexer.

Now that the lexer and parser were separated, the lexer didn't know what tokens
to generate for the parser. I modified the build system to accommodate the dance
that lex and yacc have to do to sort out their dependencies: generate the types
for the tokens, generate the lexer (and the lexer header), generate the parser,
then link (illustrated in Figure \ref{lex-yacc-dependencies}).

\section{QEMU}

\TODO{}

\subsection{QEMU's broken VIC}

\TODO{}

\end{document}
