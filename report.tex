\documentclass[12pt]{article}
\usepackage{fullpage}
\usepackage{color}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{comment}
\usepackage{verbatim}

\title{XINU Independent Study Report}
\author{David Larsen}
\date{\today}

\newcommand{\TODO}[1]{{\huge\color{red}TODO \Large #1}}
\newcommand{\code}[1]{{\tt #1}}

\begin{document}

\maketitle

\tableofcontents

\section{ARM Core Interrupt Handler}

\TODO{}

\section{XINU's platform configuration compiler}

\subsection{Adding devices to a XINU platform}

Marquette University's version of XINU includes a small compiler for
transforming a description of the hardware for a specific plaform into header
files and a routine that populates the device table at startup.

So, the description:

\begin{verbatim}
uart:
        on HARDWARE -i uartInit     -o ionull        -c ionull
                    -r uartRead    -g uartGetc       -w uartWrite 
                    -n ionull      -p uartPutc       -intr uartInterrupt

/* Two uarts on the versatile */
SERIAL0   is uart     on HARDWARE csr 0x101F1000 irq 12
\end{verbatim}

will generate a device entry like this:

\begin{verbatim}
typedef struct dentry
{
        int     num;
        int     minor;
        char    *name;
        devcall (*init)(struct dentry *);
        devcall (*open)(struct dentry *, ...);
        devcall (*close)(struct dentry *);
        devcall (*read)(struct dentry *, void *, uint);
        devcall (*write)(struct dentry *, void *, uint);
        devcall (*seek)(struct dentry *, long);
        devcall (*getc)(struct dentry *);
        devcall (*putc)(struct dentry *, char);
        devcall (*control)(struct dentry *, int, long, long);
        void    *csr;
        void    (*intr)(void);
        uchar   irq;
} device;

[...]

	{ 0, 0, "SERIAL0",
	  (void *)uartInit, (void *)ionull, (void *)ionull,
	  (void *)uartRead, (void *)uartWrite, (void *)ioerr,
	  (void *)uartGetc, (void *)uartPutc, (void *)ionull,
	  (void *)0x101f1000, (void *)uartInterrupt, 12 },
\end{verbatim}

So, a routine like \code{puts()} only needs to call
\code{dentry[\$DEVICE].write()}, without caring what kind of device it is, or
how it's implemented.

\subsection{Fixing changes in Flex}

The compiler that generated these device entries depended on the values of some
components of Flex. In Flex 2.5.35, they changed the type of \code{yyleng} from
an \code{int} to a \code{size\_t}, since the length of a token could never be
negative. It was a reasonable change, but people using Flex historically don't
include a header file defining these types \---- everyone just re-defined them
and they matched up properly. This all broke with the type change for
\code{yyleng}.

Simply changing the defined type in the compiler to a \code{size\_t} wouldn't
work; then the project would only work for people who had really up to date
systems. The compiler had to be modified so that it started building header
files and using the declarations there.

\paragraph{The tightly coupled relationship between \code{lex} and \code{yacc}}
Lex and Yacc have an interesting relationship. Lex, on its own, can happily scan
through source files and emitting tokens that have been declared in its source
file. When we bring Yacc into the picture, it's not aware of the types of
tokens that it should be getting from Lex, and it has no desire to by told by
the lexer, what it should expect. Instead, Yacc must define the tokens and pass
them off to lex.

\begin{figure}
\caption{The dependency diagram for the lexer and parser.}
\label{lex-yacc-dependencies}
\TODO{Diagram}
\end{figure}

Our parser expects to be able to inspect a lot of things from the scanner, so
that it can manually copy over some parts of the source config file verbatim.
Because of this, we have an interweaving of mutually recursive dependencies
between the scanner and the parser. The original compiler coped with this by
including the entire scanner (after being generated by Flex) into the parser.

\paragraph{Using headers}
To cope with \code{yyleng} having different type on different platforms, we
needed to have the Flex implementation of each platform specify what the
correct type to use is. Neither Flex nor Bison have system-wide headers,
instead, they are generated at build time.

Since generating a header isn't a default thing to do in Flex, the generated
lexer defines a lot of it's own types. Some structures are defined differently
in the generated header and generated lexer (possibly to hide some information
from clients?).

\begin{figure}
\label{include-c-h}\caption{This generated type errors}
In the lex.yy.h:
\begin{verbatim}
#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
    /* stuff */
#endif
\end{verbatim}

In lex.yy.c:
\begin{verbatim}
#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
    /* stuff */
    /* Even more stuff, not defined before. */
#endif
\end{verbatim}

In the parser:
\begin{verbatim}
#include "lex.yy.h"
[... snip ...]
#include "lex.yy.c"
\end{verbatim}
\end{figure}

\paragraph{Separated, at last!}
Removing the generated scanner from the parser was easy enough, since they were
re-integrated at link-time. Removing the generated lexer revealed the 
parser depended on a static function in the lexer, which it no longer had
access to at link time. This function, \code{input()}, gave provided the raw
stream of characters that the lexer was looking at. The compiler was using that
function directly to support copying some parts of the configuration file over
into the destination config verbatim. This was fixed by moving the logic for
copying code over verbatim into the lexer.

Now that the lexer and parser were separated, the lexer didn't know what tokens
to generate for the parser. I modified the build system to accommodate the dance
that lex and yacc have to do to sort out their dependencies: generate the types
for the tokens, generate the lexer (and the lexer header), generate the parser,
then link. It's easier to see Figure \ref{lex-yacc-dependencies}.

\section{QEMU}

\TODO{}

\subsection{QEMU's broken VIC}

\TODO{}

\end{document}
